package net.kodehawa.mantarobot.utils.commands;

import net.dv8tion.jda.api.entities.*;
import net.dv8tion.jda.api.utils.concurrent.Task;
import net.dv8tion.jda.internal.utils.concurrent.task.GatewayTask;
import net.kodehawa.mantarobot.core.modules.commands.base.Context;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

// This is actually mostly code from FinderUtils, but it also contains code from Fabricio's FinderUtils.
// Original code can be found at:
// https://github.com/LindseyBot/core/blob/master/src/main/java/net/notfab/lindsey/framework/command/FinderUtil.java
// And the original FinderUtil's code can be found at:
// https://github.com/JDA-Applications/JDA-Utilities/blob/master/commons/src/main/java/com/jagrosh/jdautilities/commons/utils/FinderUtil.java

// This class contains no copyright header due to the above notice. If the copyright header was autogenerated here and I didn't notice, feel free to file an issue.
public class CustomFinderUtil {

    private final static Pattern DISCORD_ID = Pattern.compile("\\d{17,20}"); // ID
    private final static Pattern FULL_USER_REF = Pattern.compile("(.{2,32})\\s*#(\\d{4})"); // $1 -> username, $2 -> discriminator
    private final static Pattern USER_MENTION = Pattern.compile("<@!?(\\d{17,20})>"); // $1 -> ID

    // Prevent instantiation
    private CustomFinderUtil() {}

    /**
     * This takes the result of the Async call of Guild#retrieveMembersByPrefix and parses it.
     * This is VERY hacky. Like **VERY**, but async is hard.
     * @param query The original query used to find the members.
     * @param result The result of Guild#retrieveMembersByPrefix
     * @return The member found. Returns null if nothing was found.
     */
    public static Member findMember(String query, List<Member> result, Context ctx) {
        // This is technically a safeguard, shouldn't be needed, but since we handle no results by giving this an empty list, it should be done.
        // If you want to handle it differently, there's findMemberDefault to return a default member.
        if(result.isEmpty()) {
            ctx.send(EmoteReference.ERROR + "Cannot find any member with that name :(");
            return null;
        }

        ArrayList<Member> exact = new ArrayList<>();
        ArrayList<Member> wrongcase = new ArrayList<>();
        ArrayList<Member> startswith = new ArrayList<>();
        ArrayList<Member> contains = new ArrayList<>();
        String lowerquery = query.toLowerCase();

        result.forEach(member -> {
            String name = member.getUser().getName();
            String effName = member.getEffectiveName();
            if(name.equals(query) || effName.equals(query))
                exact.add(member);
            else if((name.equalsIgnoreCase(query) || effName.equalsIgnoreCase(query)) && exact.isEmpty())
                wrongcase.add(member);
            else if((name.toLowerCase().startsWith(lowerquery) || effName.toLowerCase().startsWith(lowerquery)) && wrongcase.isEmpty())
                startswith.add(member);
            else if((name.toLowerCase().contains(lowerquery) || effName.toLowerCase().contains(lowerquery)) && startswith.isEmpty())
                contains.add(member);
        });

        List<Member> found;

        // Slowly becoming insane.png
        if(!exact.isEmpty())
            found = Collections.unmodifiableList(exact);
        else if(!wrongcase.isEmpty())
            found = Collections.unmodifiableList(wrongcase);
        else if(!startswith.isEmpty())
            found = Collections.unmodifiableList(startswith);
        else
            found = Collections.unmodifiableList(contains);

        if (found.isEmpty()) {
            ctx.send(EmoteReference.ERROR + "Cannot find any member with that name :(");
            return null;
        }

        if (found.size() > 1) {
            ctx.sendFormat("%sToo many users found, maybe refine your search? (ex. use name#discriminator)\n**Users found:** %s",
                    EmoteReference.THINKING,
                    found.stream().limit(7).map(m -> m.getUser().getName() + "#" + m.getUser().getDiscriminator())
                            .collect(Collectors.joining(", "))
            );

            return null;
        }

        return found.get(0);
    }

    public static Member findMemberDefault(String query, List<Member> result, Context ctx, Member member) {
        if(query.isEmpty() || result.isEmpty()) {
            return member;
        } else {
            return findMember(query, result, ctx);
        }
    }

    /**
     * Search for a member in a sync way. This is very dangerous to use but it's useful in cases where we can't use callbacks for x or y reasons.
     * This is a *very* blocking call. It will fail if called in the WS thread, as it should.
     * @param query The query to look for, for example Member#1234 or @Member or 155867458203287552
     * @param guild The guild where we want to look for the Member on.
     * @return A list of Members we found.
     */
    public static List<Member> findMembersSync(String query, Guild guild) {
        // Mention
        Matcher userMention = USER_MENTION.matcher(query);
        if (userMention.matches()) {
            return Collections.singletonList(guild.retrieveMemberById(userMention.replaceAll("$1")).complete());
        }
        // Id
        if (DISCORD_ID.matcher(query).matches()) {
            return Collections.singletonList(guild.retrieveMemberById(query).complete());
        }
        // User#Dis
        Matcher fullRefMatch = FULL_USER_REF.matcher(query);
        if (fullRefMatch.matches()) {
            String name = fullRefMatch.replaceAll("$1");
            String disc = fullRefMatch.replaceAll("$2");
            List<Member> oneMember = guild.retrieveMembersByPrefix(name, 1).get();
            if (oneMember.isEmpty()) {
                return Collections.emptyList();
            }
            Member member = oneMember.get(0);
            if (member.getUser().getDiscriminator().equals(disc)) {
                return Collections.singletonList(member);
            } else {
                return Collections.emptyList();
            }
        }

        List<Member> members = retrieveMembersByPrefix(guild, query).get();

        ArrayList<Member> exact = new ArrayList<>();
        ArrayList<Member> wrongcase = new ArrayList<>();
        ArrayList<Member> startswith = new ArrayList<>();
        ArrayList<Member> contains = new ArrayList<>();
        String lowerquery = query.toLowerCase();

        members.forEach(member -> {
            String name = member.getUser().getName();
            String effName = member.getEffectiveName();
            if(name.equals(query) || effName.equals(query))
                exact.add(member);
            else if((name.equalsIgnoreCase(query) || effName.equalsIgnoreCase(query)) && exact.isEmpty())
                wrongcase.add(member);
            else if((name.toLowerCase().startsWith(lowerquery) || effName.toLowerCase().startsWith(lowerquery)) && wrongcase.isEmpty())
                startswith.add(member);
            else if((name.toLowerCase().contains(lowerquery) || effName.toLowerCase().contains(lowerquery)) && startswith.isEmpty())
                contains.add(member);
        });

        if(!exact.isEmpty())
            return Collections.unmodifiableList(exact);
        if(!wrongcase.isEmpty())
            return Collections.unmodifiableList(wrongcase);
        if(!startswith.isEmpty())
            return Collections.unmodifiableList(startswith);

        return Collections.unmodifiableList(contains);
    }

    public static Task<List<Member>> retrieveMembersByPrefix(Guild guild, String query) {
        if(query.trim().isEmpty()) {
            // This is next-level hacky, LMAO.
            // Basically we handle giving an empty value to this, and just return an empty list in that case.
            CompletableFuture<List<Member>> result = new CompletableFuture<>();
            result.complete(Collections.emptyList());
            return new GatewayTask<>(result, () -> {});
        }

        return guild.retrieveMembersByPrefix(query, 10);
    }
}
